"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addImportCore = exports.extractImport = void 0;
var common_1 = require("./common");
var path_1 = require("path");
var fs_1 = require("fs");
var util_1 = require("./util");
var path = require("path");
// Parse Imports
var EXTENSIONS = ['.d.ts', '.ts', '.tsx', '.js', '.jsx'];
var isRelativeToBaseDir = function (baseDir, from) {
    return (0, fs_1.existsSync)((0, path_1.resolve)(baseDir, "".concat(from, ".js"))) ||
        (0, fs_1.existsSync)((0, path_1.resolve)(baseDir, "".concat(from, ".ts"))) ||
        (0, fs_1.existsSync)((0, path_1.resolve)(baseDir, "".concat(from, ".d.ts"))) ||
        (0, fs_1.existsSync)((0, path_1.resolve)(baseDir, "".concat(from, ".tsx"))) ||
        (0, fs_1.existsSync)((0, path_1.resolve)(baseDir, from, 'index.js')) ||
        (0, fs_1.existsSync)((0, path_1.resolve)(baseDir, from, 'index.ts')) ||
        (0, fs_1.existsSync)((0, path_1.resolve)(baseDir, from, 'index.tsx'));
};
var joinWithBaseUrl = function (baseUrl, from) {
    if (!from.startsWith(baseUrl))
        return path.join(baseUrl, from);
    return from;
};
var extractImport = function (decl) {
    var from = (0, common_1.getFrom)(decl.moduleSpecifier);
    var importClause = decl.importClause;
    if (!importClause)
        return {
            from: from,
            what: common_1.STAR,
        };
    var namedBindings = importClause.namedBindings;
    var importDefault = !!importClause.name ? ['default'] : [];
    if (!namedBindings) {
        return {
            from: from,
            what: importDefault,
        };
    }
    var isStar = !!namedBindings.name;
    var importNames = isStar
        ? common_1.STAR
        : namedBindings.elements.map(function (e) { return (e.propertyName || e.name).text; });
    // note on namespaces: when importing a namespace, we cannot differentiate that from another element.
    // (we differentiate on *export*)
    return {
        from: from,
        what: importDefault.concat(importNames),
    };
};
exports.extractImport = extractImport;
var declarationFilePatch = function (matchedPath) {
    return matchedPath.endsWith('.d') && (0, fs_1.existsSync)("".concat(matchedPath, ".ts"))
        ? matchedPath.slice(0, -2)
        : matchedPath;
};
var addImportCore = function (fw, pathIn, imports, baseUrl, tsconfigPathsMatcher) {
    var from = fw.from, what = fw.what;
    var getKey = function (from) {
        if (from[0] == '.') {
            // An undefined return indicates the import is from 'index.ts' or similar == '.'
            return (0, path_1.resolve)((0, path_1.dirname)(pathIn), from) || '.';
        }
        else {
            var matchedPath = void 0;
            if (isRelativeToBaseDir(baseUrl, from)) {
                return joinWithBaseUrl(baseUrl, from);
            }
            if (tsconfigPathsMatcher &&
                (matchedPath = tsconfigPathsMatcher(from, undefined, undefined, EXTENSIONS))) {
                var matched = declarationFilePatch(matchedPath);
                if (!matched.startsWith(baseUrl))
                    return path.join(baseUrl, matched);
                // Use join to normalize path separators, since tsconfig-path can return mixed path separators (Windows)
                return path.join(matched);
            }
            return joinWithBaseUrl(baseUrl, from);
        }
    };
    var key = getKey(from);
    var items = imports[key] || [];
    imports[key] = items.concat(what).filter(util_1.isUnique);
    return key;
};
exports.addImportCore = addImportCore;
//# sourceMappingURL=import.js.map